{"ast":null,"code":"import _slicedToArray from \"@babel/runtime/helpers/esm/slicedToArray\";\nvar __jsx = React.createElement;\nimport React from \"react\";\nimport mapboxgl from \"mapbox-gl\";\nimport polyline from \"@mapbox/polyline\";\nimport useMedia from \"use-media\";\nvar latLngCircleSize = 10;\nvar latLngCircleOpacity = 1;\nvar style = {\n  height: \"300px\",\n  width: \"100%\"\n};\n\nvar SmallMap = function SmallMap(props) {\n  var mapContainer = React.useRef(null);\n\n  var _React$useState = React.useState(null),\n      _React$useState2 = _slicedToArray(_React$useState, 2),\n      map = _React$useState2[0],\n      setMap = _React$useState2[1];\n\n  var mediaDarkMode = useMedia(\"(prefers-color-scheme: dark)\");\n  var decodedPolyline = polyline.toGeoJSON(props.activitySummary.map.polyline);\n  var decodedPolylineCoordinates = decodedPolyline.coordinates;\n  mapboxgl.accessToken = \"pk.eyJ1IjoicDBwbWFrZXIiLCJhIjoiY2lzOXliOGlrMDA2ODJ5bzJ4YjNnb29qdSJ9.hf19Sca7oYCcR8kRlx07Rw\";\n  React.useEffect(function () {\n    var isDarkMode = window.matchMedia(\"(prefers-color-scheme: dark)\").matches;\n    var mapTheme;\n\n    if (mediaDarkMode) {\n      // console.log(\"dark mode\");\n      mapTheme = \"mapbox://styles/mapbox/dark-v10\";\n    } else {\n      // console.log(\"light mode\");\n      mapTheme = \"mapbox://styles/p0pmaker/cjrf0kzjd4xde2tqwor6ltd0u\";\n    }\n\n    var map;\n\n    var initializeMap = function initializeMap(_ref) {\n      var setMap = _ref.setMap,\n          mapContainer = _ref.mapContainer;\n      // console.log(\"init map\");\n      map = new mapboxgl.Map({\n        container: mapContainer.current,\n        style: mapTheme,\n        center: [props.activitySummary.start_latlng[1], props.activitySummary.start_latlng[0]],\n        zoom: 10\n      });\n      map.scrollZoom.disable();\n      map.addControl(new mapboxgl.FullscreenControl());\n      map.addControl(new mapboxgl.NavigationControl());\n      map.on(\"load\", function () {\n        setMap(map);\n        map.resize();\n        map.addLayer({\n          id: \"start\",\n          type: \"circle\",\n          source: {\n            type: \"geojson\",\n            data: {\n              type: \"Feature\",\n              properties: {\n                description: \"Activitiy Start\"\n              },\n              geometry: {\n                type: \"Point\",\n                coordinates: decodedPolylineCoordinates[0]\n              }\n            }\n          },\n          paint: {\n            \"circle-color\": \"#f03434\",\n            \"circle-radius\": latLngCircleSize,\n            \"circle-opacity\": latLngCircleOpacity\n          }\n        });\n        map.addLayer({\n          id: \"end\",\n          type: \"circle\",\n          source: {\n            type: \"geojson\",\n            data: {\n              type: \"Feature\",\n              properties: {\n                description: \"Activitiy End\"\n              },\n              geometry: {\n                type: \"Point\",\n                coordinates: decodedPolylineCoordinates.pop()\n              }\n            }\n          },\n          paint: {\n            \"circle-color\": \"#479C1F\",\n            \"circle-radius\": latLngCircleSize,\n            \"circle-opacity\": latLngCircleOpacity\n          }\n        });\n        map.addLayer({\n          id: \"route\",\n          type: \"line\",\n          source: {\n            type: \"geojson\",\n            data: {\n              type: \"Feature\",\n              properties: {},\n              geometry: {\n                type: \"LineString\",\n                coordinates: decodedPolylineCoordinates\n              }\n            }\n          },\n          layout: {\n            \"line-join\": \"round\",\n            \"line-cap\": \"round\"\n          },\n          paint: {\n            \"line-color\": \"#0a67f2\",\n            \"line-width\": 2\n          }\n        }); // Geographic coordinates of the LineString\n\n        var coordinates = decodedPolylineCoordinates; // Pass the first coordinates in the LineString to `lngLatBounds` &\n        // wrap each coordinate pair in `extend` to include them in the bounds\n        // result. A variation of this technique could be applied to zooming\n        // to the bounds of multiple Points or Polygon geomteries - it just\n        // requires wrapping all the coordinates with the extend method.\n\n        var bounds = coordinates.reduce(function (bounds, coord) {\n          return bounds.extend(coord);\n        }, new mapboxgl.LngLatBounds(coordinates[0], coordinates[0]));\n        map.fitBounds(bounds, {\n          padding: 20\n        });\n      });\n    };\n\n    if (!map) initializeMap({\n      setMap: setMap,\n      mapContainer: mapContainer\n    });\n  }, [mediaDarkMode]);\n  return __jsx(\"div\", {\n    style: style,\n    ref: function ref(el) {\n      return mapContainer.current = el;\n    }\n  });\n};\n\nexport default SmallMap;","map":null,"metadata":{},"sourceType":"module"}